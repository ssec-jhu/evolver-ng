Developing Calibrators
======================

In this framework, a calibrator is attached to a hardware driver and servers a
dual purpose:

#. It provides a mechanism to perform a calibration procedure on the hardware,
   guiding the user through a step-by-step process, taking real-world and
   digital measurements as needed. The output of a procedure is a file, that is
   then read in by the calibrator to provide transformations.
#. It contains the :py:class:`Transformer` s that a hardware within its read
   logic will use to transform the raw voltage readings to physical units (based
   on the data collected during the calibration procedure).


The reason for this dual purpose is that the data generated by the calibration
procedure and the data required by the transformer for a fit are closely linked.
The calibrator is singly responsible for how to call transformers with necessary
data and parameters, and how to gather those data.

Procedures definition
---------------------

A calibration procedure is the interface to the user for performing the
necessary steps and gathering the data needed to calibrate a hardware. The
:py:class:`CalibrationProcedure` interface contains the framework for defining
and executing a procedure within the applicaiton, as a developer of a
calibrator, you will implement the
:py:meth:`Calibrator.create_calibration_procedure` method which is responsible
for constructing a :py:class:`CalibrationProcedure` object and storing it within
the procedure.

A procedure is a sequence of :py:class:`CalibrationAction`, which themselves
contain any required input data to get from the user, and contain an
:py:meth:`CalibrationAction.execute` method which is called during the procedure
upon user input. An example action (abbreviated)::

    class ReferenceValueAction(CalibrationAction):
        # define this to require input for a given action
        class FormModel(BaseModel):
            temperature: float = Field(..., title="Temperature", description="Temperature in degrees Celsius")

        def execute(self, state: CalibrationStateModel, payload: Optional[FormModel] = None):
            # store measurements, read sensor data, do nothing etc.
            state.measured[self.vial_idx]["reference"].append(payload.temperature)
            return state

In the above, note:

* A `FormModel` class is defined, this is what the framework uses to request
  data from the user (in the form of an HTML form, for example). A Post request to
  the endpoint to perform this action must contain the data in the form as per its
  definition, and this will be passed to the `execute` method as the `payload`.
* The `execute` method is called when the user completes the aciton (e.g. by
  issuing a POST request to the endpoint). In this case the method stores the
  reference value within the state. In some cases, the action may not require
  anything to be done, for example when the action is instructing the user to
  prepare something in the physical environment. For any action, they will have
  to call it, which indicates their completion of the action.
* The `state` parameter is a :py:class:`CalibrationStateModel` object, which
  contains some information about the current state of the calibration procedure,
  in addition to the measured data and optionally any other state data necessary
  for the specific procedure (e.g. to be communicated to subsequent actions).

Given actions such as the above, a procedure could then be added to a calibrator
in the following manner::

    class MyCalibrator(Calibrator):
        def create_calibration_procedure(self, selected_hardware: Hardware, resume: bool = False):
            # enable resume
            procedure_state = CalibrationStateModel.load(self.procedure_file) if resume else None
            procedure = CalibrationProcedure(
                state=procedure_state.model_dump() if procedure_state else None, hardware=selected_hardware
            )
            # add our specific actions
            procedure.add_action(ReferenceValueAction())
            procedure.add_action(AnotherAction())
            # set the procedure on the calibrator
            self.calibration_procedure = procedure

The above contains the necessary logic to resume a previously saved procedure
from an existing procedure file (set on the calibrator) using the resume flag.

Procedure flow
--------------

After the procedure is created, a client (for example, the web UI) runs the
procedure via the following steps:

#. Gets actions - calling :py:meth:`CalibrationProcedure.get_actions`
#. Dispatches a given action - calling :py:meth:`CalibrationProcedure.dispatch_action`
#. Periodically saves the state (to disk), calling :py:meth:`CalibrationProcedure.save`
#. optionally undoes the last action, calling :py:meth:`CalibrationProcedure.undo`
#. Applies the procedure - calling :py:meth:`CalibrationProcedure.apply`. This
   persists the completed procedure data to the calibrator in configuration for
   subsequent use.

As a developer of a procedure, all of the above will be handled by the
framework and clients, but it is useful to understand the role of the procedure,
actions and state in the overall flow.

Transformers
------------

